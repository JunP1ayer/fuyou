// üì± PWAÊ©üËÉΩ„Éï„ÉÉ„ÇØ

import { useState, useEffect, useCallback, useRef } from 'react';

interface PWAInstallPrompt {
  prompt: () => Promise<void>;
  userChoice: Promise<{ outcome: 'accepted' | 'dismissed' }>;
}

interface PWACapabilities {
  isInstallable: boolean;
  isInstalled: boolean;
  isOnline: boolean;
  hasNotificationPermission: boolean;
  hasCameraAccess: boolean;
  hasLocationAccess: boolean;
  supportsBackgroundSync: boolean;
  supportsPushNotifications: boolean;
}

interface NotificationOptions {
  title: string;
  body: string;
  icon?: string;
  tag?: string;
  requireInteraction?: boolean;
  silent?: boolean;
  actions?: Array<{
    action: string;
    title: string;
    icon?: string;
  }>;
}

export const usePWA = () => {
  const [capabilities, setCapabilities] = useState<PWACapabilities>({
    isInstallable: false,
    isInstalled: false,
    isOnline: navigator.onLine,
    hasNotificationPermission: false,
    hasCameraAccess: false,
    hasLocationAccess: false,
    supportsBackgroundSync: false,
    supportsPushNotifications: false,
  });

  const [installPrompt, setInstallPrompt] = useState<PWAInstallPrompt | null>(null);
  const [updateAvailable, setUpdateAvailable] = useState(false);
  const serviceWorkerRef = useRef<ServiceWorkerRegistration | null>(null);

  // Service Worker ÁôªÈå≤ (‰∏ÄÊôÇÁöÑ„Å´ÁÑ°ÂäπÂåñ)
  useEffect(() => {
    // Service Worker„ÇíÁÑ°ÂäπÂåñ„Åó„Å¶„ÉÜ„Çπ„Éà
    console.log('üîß Service Worker registration disabled for debugging');
    return;
    
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker
        .register('/sw-advanced.js')
        .then((registration) => {
          serviceWorkerRef.current = registration;
          console.log('Service Worker registered:', registration);

          // Êõ¥Êñ∞„ÉÅ„Çß„ÉÉ„ÇØ
          registration.addEventListener('updatefound', () => {
            const newWorker = registration.installing;
            if (newWorker) {
              newWorker.addEventListener('statechange', () => {
                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                  setUpdateAvailable(true);
                }
              });
            }
          });

          // „É°„ÉÉ„Çª„Éº„Ç∏„É™„Çπ„Éä„Éº
          navigator.serviceWorker.addEventListener('message', (event) => {
            const { type, data } = event.data;
            
            switch (type) {
              case 'sync-success':
                console.log('Background sync successful:', data);
                // „Éà„Éº„Çπ„Éà„Å™„Å©„ÅßÈÄöÁü•
                break;
              case 'sync-error':
                console.error('Background sync failed:', data);
                // „Ç®„É©„ÉºÈÄöÁü•
                break;
              default:
                console.log('SW Message:', type, data);
            }
          });
        })
        .catch((error) => {
          console.error('Service Worker registration failed:', error);
        });
    }
  }, []);

  // „Ç§„É≥„Çπ„Éà„Éº„É´„Éó„É≠„É≥„Éó„ÉàÊ§úÂá∫
  useEffect(() => {
    const handleBeforeInstallPrompt = (event: Event) => {
      event.preventDefault();
      setInstallPrompt(event as any);
      setCapabilities(prev => ({ ...prev, isInstallable: true }));
    };

    const handleAppInstalled = () => {
      setCapabilities(prev => ({ ...prev, isInstalled: true, isInstallable: false }));
      setInstallPrompt(null);
    };

    window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
    window.addEventListener('appinstalled', handleAppInstalled);

    return () => {
      window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
      window.removeEventListener('appinstalled', handleAppInstalled);
    };
  }, []);

  // „Ç™„É≥„É©„Ç§„É≥/„Ç™„Éï„É©„Ç§„É≥Áä∂ÊÖãÁõ£Ë¶ñ
  useEffect(() => {
    const handleOnline = () => {
      setCapabilities(prev => ({ ...prev, isOnline: true }));
    };

    const handleOffline = () => {
      setCapabilities(prev => ({ ...prev, isOnline: false }));
    };

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  // Ê©üËÉΩ„ÉÅ„Çß„ÉÉ„ÇØ
  useEffect(() => {
    const checkCapabilities = async () => {
      const updates: Partial<PWACapabilities> = {};

      // PWA„Ç§„É≥„Çπ„Éà„Éº„É´Áä∂ÊÖã„ÉÅ„Çß„ÉÉ„ÇØ
      if (window.matchMedia('(display-mode: standalone)').matches || 
          (window.navigator as any).standalone) {
        updates.isInstalled = true;
      }

      // ÈÄöÁü•Ê®©Èôê„ÉÅ„Çß„ÉÉ„ÇØ
      if ('Notification' in window) {
        updates.hasNotificationPermission = Notification.permission === 'granted';
      }

      // „Ç´„É°„É©„Ç¢„ÇØ„Çª„Çπ„ÉÅ„Çß„ÉÉ„ÇØ
      if ('mediaDevices' in navigator && 'getUserMedia' in navigator.mediaDevices) {
        try {
          const devices = await navigator.mediaDevices.enumerateDevices();
          updates.hasCameraAccess = devices.some(device => device.kind === 'videoinput');
        } catch (error) {
          updates.hasCameraAccess = false;
        }
      }

      // ‰ΩçÁΩÆÊÉÖÂ†±„Ç¢„ÇØ„Çª„Çπ„ÉÅ„Çß„ÉÉ„ÇØ
      if ('geolocation' in navigator) {
        try {
          await new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(resolve, reject, { timeout: 1000 });
          });
          updates.hasLocationAccess = true;
        } catch (error) {
          updates.hasLocationAccess = false;
        }
      }

      // „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÂêåÊúü„Çµ„Éù„Éº„Éà„ÉÅ„Çß„ÉÉ„ÇØ
      if ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) {
        updates.supportsBackgroundSync = true;
      }

      // „Éó„ÉÉ„Ç∑„É•ÈÄöÁü•„Çµ„Éù„Éº„Éà„ÉÅ„Çß„ÉÉ„ÇØ
      if ('serviceWorker' in navigator && 'PushManager' in window) {
        updates.supportsPushNotifications = true;
      }

      setCapabilities(prev => ({ ...prev, ...updates }));
    };

    checkCapabilities();
  }, []);

  // „Ç¢„Éó„É™„Ç§„É≥„Çπ„Éà„Éº„É´
  const installApp = useCallback(async () => {
    if (!installPrompt) return false;

    try {
      await installPrompt.prompt();
      const choice = await installPrompt.userChoice;
      
      if (choice.outcome === 'accepted') {
        console.log('App installation accepted');
        return true;
      } else {
        console.log('App installation dismissed');
        return false;
      }
    } catch (error) {
      console.error('App installation failed:', error);
      return false;
    } finally {
      setInstallPrompt(null);
    }
  }, [installPrompt]);

  // ÈÄöÁü•Ê®©ÈôêË¶ÅÊ±Ç
  const requestNotificationPermission = useCallback(async () => {
    if (!('Notification' in window)) {
      console.warn('Notifications not supported');
      return false;
    }

    if (Notification.permission === 'granted') {
      return true;
    }

    const permission = await Notification.requestPermission();
    const granted = permission === 'granted';
    
    setCapabilities(prev => ({ ...prev, hasNotificationPermission: granted }));
    return granted;
  }, []);

  // ÈÄöÁü•ÈÄÅ‰ø°
  const sendNotification = useCallback(async (options: NotificationOptions) => {
    if (!capabilities.hasNotificationPermission) {
      const granted = await requestNotificationPermission();
      if (!granted) return false;
    }

    try {
      if (serviceWorkerRef.current) {
        // Service WorkerÁµåÁî±„ÅßÈÄöÁü•
        await serviceWorkerRef.current.showNotification(options.title, {
          body: options.body,
          icon: options.icon || '/icon-192x192.png',
          tag: options.tag,
          requireInteraction: options.requireInteraction,
          silent: options.silent,
        });
      } else {
        // Áõ¥Êé•ÈÄöÁü•
        new Notification(options.title, {
          body: options.body,
          icon: options.icon,
          tag: options.tag,
          requireInteraction: options.requireInteraction,
          silent: options.silent,
        });
      }
      return true;
    } catch (error) {
      console.error('Notification failed:', error);
      return false;
    }
  }, [capabilities.hasNotificationPermission, requestNotificationPermission]);

  // „Éó„ÉÉ„Ç∑„É•ÈÄöÁü•ÁôªÈå≤
  const subscribeToPushNotifications = useCallback(async () => {
    if (!serviceWorkerRef.current || !capabilities.supportsPushNotifications) {
      return null;
    }

    try {
      const subscription = await serviceWorkerRef.current.pushManager.subscribe({
        userVisibleOnly: true,
        applicationServerKey: process.env.REACT_APP_VAPID_PUBLIC_KEY,
      });

      // „Çµ„Éº„Éê„Éº„Å´ÁôªÈå≤ÊÉÖÂ†±„ÇíÈÄÅ‰ø°
      await fetch('/api/push-subscriptions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(subscription),
      });

      console.log('Push subscription successful:', subscription);
      return subscription;
    } catch (error) {
      console.error('Push subscription failed:', error);
      return null;
    }
  }, [capabilities.supportsPushNotifications]);

  // „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÂêåÊúü
  const syncInBackground = useCallback(async (data: any) => {
    if (!serviceWorkerRef.current || !capabilities.supportsBackgroundSync) {
      console.warn('Background sync not supported');
      return false;
    }

    try {
      // Service Worker„Å´ÂêåÊúü„Éá„Éº„Çø„ÇíÈÄÅ‰ø°
      serviceWorkerRef.current.active?.postMessage({
        type: 'add-to-sync-queue',
        data,
      });

      if ('sync' in serviceWorkerRef.current) {
        await (serviceWorkerRef.current as any).sync.register('sync-data');
      }
      console.log('Background sync registered');
      return true;
    } catch (error) {
      console.error('Background sync failed:', error);
      return false;
    }
  }, [capabilities.supportsBackgroundSync]);

  // „Ç¢„Éó„É™Êõ¥Êñ∞
  const updateApp = useCallback(async () => {
    if (!serviceWorkerRef.current) return false;

    try {
      // Êñ∞„Åó„ÅÑService Worker„Çí„Ç¢„ÇØ„ÉÜ„Ç£„ÉñÂåñ
      serviceWorkerRef.current.waiting?.postMessage({ type: 'skip-waiting' });
      
      // „Éö„Éº„Ç∏„É™„É≠„Éº„Éâ
      window.location.reload();
      return true;
    } catch (error) {
      console.error('App update failed:', error);
      return false;
    }
  }, []);

  // „Ç™„Éï„É©„Ç§„É≥„Éá„Éº„ÇøÂêåÊúü
  const syncOfflineData = useCallback(async () => {
    if (!serviceWorkerRef.current) return false;

    serviceWorkerRef.current.active?.postMessage({ type: 'sync-now' });
    return true;
  }, []);

  // Ê©üËÉΩÊ§úÂá∫
  const hasFeature = useCallback((feature: keyof PWACapabilities) => {
    return capabilities[feature];
  }, [capabilities]);

  return {
    capabilities,
    installPrompt: installPrompt !== null,
    updateAvailable,
    installApp,
    requestNotificationPermission,
    sendNotification,
    subscribeToPushNotifications,
    syncInBackground,
    updateApp,
    syncOfflineData,
    hasFeature,
  };
};